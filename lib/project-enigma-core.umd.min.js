!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e="undefined"!=typeof globalThis?globalThis:e||self).EnigmaCore={})}(this,(function(e){"use strict";class t{constructor(e,t=0){if(this.notFindError=new Error("输入错误，没有指定的映射"),this.reflexSettingError=new Error("转轮设定错误，转轮映射应当为由数字0～25组成的长度为26且元素不重复的数组"),this.currentPosition=0,this.setWheelPosition(t),26!==e.length)throw this.reflexSettingError;{const t={};if(e.forEach((e=>{if(t[e]=e,e<0||e>25)throw this.reflexSettingError})),26!==Object.keys(t).length)throw this.reflexSettingError;this.setting=e}}get position(){return this.currentPosition}setWheelPosition(e=-1){return this.currentPosition=-1!==e?+e%26:(this.currentPosition+1)%26,this}toLeft(e){const t=e;let s=-1;if(this.setting.some(((e,r)=>(s=r,e===t)))&&-1!==s)return(s+this.position)%26;throw this.notFindError}toRight(e){const t=e-this.position,s=t<0?t+26:t,r=this.setting[s]??-1;if(-1!==r)return r;throw this.notFindError}}class s{constructor(e){if(this.settingError=new Error("反射器设置错误，反射器设置应为数字0～25的相互映射，映射条目数量应为13，且不可重复，每个元素仅能出现一次"),this.notFindError=new Error("映射失败，请检查配置"),13!==e.length)throw this.settingError;const t={};if(e.forEach((e=>{if(e.value1<0||e.value1>25||e.value2<0||e.value2>25)throw this.settingError;t[e.value1]=e.value2,t[e.value2]=e.value1})),26!==Object.keys(t).length)throw this.settingError;this.reflexMap=t}getValue(e){const t=this.reflexMap[e]??-1;if(-1!==t)return t;throw this.notFindError}}const r=()=>{const e=new Map;return{addEventListener:(t,s)=>{const r=Date.now(),i=e.get(t)??new Map;return i.set(r,s),e.set(t,i),r},removeEventListener:(t,s)=>{const r=e.get(t);r&&(r.delete(s),e.set(t,r))},emitEvent:(t,s)=>{const r=e.get(t);r&&r.forEach((e=>{e(s)}))}}};class i{constructor(e=[]){this.wordMap=new Map,this.error=new Error("字符映射设置错误,每个字符只能被映射一次"),this.setWordMaps(e)}setWordMaps(e=[]){this.wordMap=new Map;const t={},s=/^[A-Z]$/;e.forEach((e=>{const r=e.value1.toUpperCase(),i=e.value2.toUpperCase();if(!s.test(r)||!s.test(i))throw this.error;t[r]=t[r]??1,t[i]=t[i]??1,this.wordMap.set(r,i),this.wordMap.set(i,r)}));for(const e in t)if(t[e]>1)throw this.error}getValue(e){return this.wordMap.get(e)??e}}var o=["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],n=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25],[13,1,22,6,0,18,2,5,7,3,8,4,9,25,10,12,14,17,16,19,21,20,23,15,11,24],[7,4,0,1,12,21,16,3,24,5,6,9,14,10,13,8,11,15,17,2,23,18,20,22,25,19]],h=[0,0,0],l=[{value1:1,value2:2},{value1:3,value2:4},{value1:5,value2:6},{value1:7,value2:8},{value1:9,value2:10},{value1:11,value2:12},{value1:13,value2:14},{value1:15,value2:16},{value1:17,value2:18},{value1:19,value2:20},{value1:21,value2:22},{value1:23,value2:24},{value1:25,value2:0}],a=[],p={inputMapper:o,wheels:n,wheelsPosition:h,reflector:l,wordMaps:a};const u=Object.freeze({__proto__:null,inputMapper:o,wheels:n,wheelsPosition:h,reflector:l,wordMaps:a,default:p});e.Enigma=class{constructor(e){this.wordMapper=new i(u.wordMaps);const{addEventListener:t,removeEventListener:s,emitEvent:o}=r();this.addEventListener=t,this.removeEventListener=s,this.emitEvent=o;const{inputMapper:n,wheels:h,wheelsPosition:l,reflector:a,wordMaps:p}=e??u;this.setInputMapper(n??u.inputMapper),this.setWheelsSetting(h??u.wheels),this.setWheelsPosition(l??u.wheelsPosition),this.setReflectorSetting(a??u.reflector),this.setWordMapperSetting(p??u.wordMaps)}get wheels(){return this._wheels}get reflector(){return this._reflector}get wheelsSetting(){return this._wheelsSetting}get reflectorSetting(){return this._reflectorSetting}get inputMapper(){return this._inputMapper}setReflectorSetting(e){return this._reflectorSetting=e,this._reflector=new s(e),this.emitEvent("reflectorSettingChange",e),this}setWheelsSetting(e){return this._wheelsSetting=e,this._wheels=[],this.wheelsSetting.forEach((e=>{this._wheels.push(new t(e))})),this._wheels.reverse(),this.emitEvent("wheelSettingChange",e),this.emitEvent("wheelPositionChange",this.wheels.map((e=>e.position)).reverse()),this}setInputMapper(e){return this._inputMapper=e.map((e=>e.toUpperCase())),this.emitEvent("inputMapperChange",e),this}setWheelsPosition(e){return this.wheelsPosition=e,this.wheelsPosition.reverse(),this.wheels.forEach(((e,t)=>{e.setWheelPosition(this.wheelsPosition[t]??0)})),this.emitEvent("wheelPositionChange",this.wheels.map((e=>e.position)).reverse()),this}setWordMapperSetting(e){return this.wordMapper.setWordMaps(e),this.emitEvent("wordMapsChange",e),this}input(e){const t=e.split("").map((e=>e.toUpperCase())),s=/^[A-Z]$/,r=[];t.forEach((e=>{if(s.test(e)){const t=this.wordMapper.getValue(e),s=this.inputMapper.indexOf(t);if(-1===s)throw new Error("非法输入");const i=this.wheelProcess(s,"left"),o=this.reflector.getValue(i),n=this.wheelProcess(o,"right"),h=this.inputMapper[n],l=this.wordMapper.getValue(h);r.push(l)}else r.push(e)}));const i=r.join("");return this.emitEvent("input",i),i}wheelProcess(e,t){let s=e;switch(t){case"left":this.increaseWheel(),this.wheels.forEach((e=>{s=e.toLeft(s)}));break;case"right":[...this.wheels].reverse().forEach((e=>{s=e.toRight(s)}));break}return s}increaseWheel(){this.wheels.some((e=>(e.setWheelPosition(),0!==e.position))),this.emitEvent("wheelPositionChange",this.wheels.map((e=>e.position)).reverse())}},e.Reflector=s,e.SettingTemplate=u,e.Wheel=t,e.WordMapper=i,e.createEventHandler=r,Object.defineProperty(e,"__esModule",{value:!0})}));
