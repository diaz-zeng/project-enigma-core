class e{constructor(e,t=0){if(this.notFindError=new Error("输入错误，没有指定的映射"),this.reflexSettingError=new Error("转轮设定错误，转轮映射应当为由数字0～25组成的长度为26且元素不重复的数组"),this.currentPosition=0,this.setWheelPosition(t),26!==e.length)throw this.reflexSettingError;{const t={};if(e.forEach((e=>{if(t[e]=e,e<0||e>25)throw this.reflexSettingError})),26!==Object.keys(t).length)throw this.reflexSettingError;this.codes=e}}get position(){return this.currentPosition}setWheelPosition(e=-1){return this.currentPosition=-1!==e?+e%26:(this.currentPosition+1)%26,this}toLeft(e){const t=(e+this.position)%26;let s=-1;if(this.codes.some(((e,r)=>(s=r,e===t)))&&-1!==s)return s;throw this.notFindError}toRight(e){const t=this.codes[e]??-1;if(-1!==t)return(t-this.position+26)%26;throw this.notFindError}}class t{constructor(e){if(this.settingError=new Error("反射器设置错误，反射器设置应为数字0～25的相互映射，映射条目数量应为13，且不可重复，每个元素仅能出现一次"),this.notFindError=new Error("映射失败，请检查配置"),13!==e.length)throw this.settingError;const t={};if(e.forEach((e=>{if(e.value1<0||e.value1>25||e.value2<0||e.value2>25)throw this.settingError;t[e.value1]=e.value2,t[e.value2]=e.value1})),26!==Object.keys(t).length)throw this.settingError;this.reflexMap=t}getValue(e){const t=this.reflexMap[e]??-1;if(-1!==t)return t;throw this.notFindError}}const s=()=>{const e=new Map;return{addEventListener:(t,s)=>{const r=Date.now(),i=e.get(t)??new Map;return i.set(r,s),e.set(t,i),r},removeEventListener:(t,s)=>{const r=e.get(t);r&&(r.delete(s),e.set(t,r))},emitEvent:(t,s)=>{const r=e.get(t);r&&r.forEach((e=>{e(s)}))}}};class r{constructor(e=[]){this.wordMap=new Map,this.error=new Error("字符映射设置错误,每个字符只能被映射一次"),this.setWordMaps(e)}setWordMaps(e=[]){this.wordMap=new Map;const t={},s=/^[A-Z]$/;e.forEach((e=>{const r=e.value1.toUpperCase(),i=e.value2.toUpperCase();if(!s.test(r)||!s.test(i))throw this.error;t[r]=t[r]??1,t[i]=t[i]??1,this.wordMap.set(r,i),this.wordMap.set(i,r)}));for(const e in t)if(t[e]>1)throw this.error}getValue(e){return this.wordMap.get(e)??e}}var i=["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],o=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25],[13,1,22,6,0,18,2,5,7,3,8,4,9,25,10,12,14,17,16,19,21,20,23,15,11,24],[7,4,0,1,12,21,16,3,24,5,6,9,14,10,13,8,11,15,17,2,23,18,20,22,25,19]],n=[0,0,0],h=[{value1:1,value2:2},{value1:3,value2:4},{value1:5,value2:6},{value1:7,value2:8},{value1:9,value2:10},{value1:11,value2:12},{value1:13,value2:14},{value1:15,value2:16},{value1:17,value2:18},{value1:19,value2:20},{value1:21,value2:22},{value1:23,value2:24},{value1:25,value2:0}],l=[],a={inputMapper:i,wheels:o,wheelsPosition:n,reflector:h,wordMaps:l};const p=Object.freeze({__proto__:null,inputMapper:i,wheels:o,wheelsPosition:n,reflector:h,wordMaps:l,default:a});class u{constructor(e){this.wordMapper=new r(p.wordMaps),this._wheelsSetting=p.wheels,this._reflectorSetting=p.reflector,this._inputMapper=p.inputMapper,this.wheelsPosition=p.wheelsPosition;const{addEventListener:t,removeEventListener:i,emitEvent:o}=s();this.addEventListener=t,this.removeEventListener=i,this.emitEvent=o;const{inputMapper:n,wheels:h,wheelsPosition:l,reflector:a,wordMaps:u}=e??p;this.setInputMapper(n),this.setWheelsSetting(h),this.setWheelsPosition(l),this.setReflectorSetting(a),this.setWordMapperSetting(u)}get wheels(){return this._wheels}get reflector(){return this._reflector}get wheelsSetting(){return this._wheelsSetting}get reflectorSetting(){return this._reflectorSetting}get inputMapper(){return this._inputMapper}setReflectorSetting(e){return this._reflectorSetting=e,this._reflector=new t(e),this.emitEvent("reflectorSettingChange"),this}setWheelsSetting(t){return this._wheelsSetting=t,this._wheels=[],this.wheelsSetting.forEach((t=>{this._wheels.push(new e(t))})),this._wheels.reverse(),this.emitEvent("wheelSettingChange"),this}setInputMapper(e){return this._inputMapper=e.map((e=>e.toUpperCase())),this.emitEvent("inputMapperChange"),this}setWheelsPosition(e){return this.wheelsPosition=e??p.wheelsPosition,this.wheelsPosition.reverse(),this.wheels.forEach(((e,t)=>{e.setWheelPosition(this.wheelsPosition[t]??0)})),this.emitEvent("wheelPositionChange",this.wheels.map((e=>e.position)).reverse()),this}setWordMapperSetting(e){return this.wordMapper.setWordMaps(e),this.emitEvent("wordMapsChange"),this}input(e){const t=e.split("").map((e=>e.toUpperCase())),s=/^[A-Z]$/,r=[];return t.forEach((e=>{if(s.test(e)){const t=this.wordMapper.getValue(e),s=this.inputMapper.indexOf(t);if(-1===s)throw new Error("非法输入");const i=this.wheelProcess(s,"left"),o=this.reflector.getValue(i),n=this.wheelProcess(o,"right"),h=this.inputMapper[n],l=this.wordMapper.getValue(h);r.push(l)}else r.push(e)})),r.join("")}wheelProcess(e,t){let s=e;switch(t){case"left":this.increaseWheel(),this.wheels.forEach((e=>{s=e.toLeft(s)}));break;case"right":[...this.wheels].reverse().forEach((e=>{s=e.toRight(s)}));break}return s}increaseWheel(){this.wheels.some(((e,t)=>(e.setWheelPosition(),0!==e.position))),this.emitEvent("wheelPositionChange",this.wheels.map((e=>e.position)).reverse())}}export{u as Enigma,t as Reflector,p as SettingTemplate,e as Wheel,r as WordMapper,s as createEventHandler};
