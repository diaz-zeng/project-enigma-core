"use strict";Object.defineProperty(exports,"__esModule",{value:!0});class e{constructor(e,t=0){if(this.notFindError=new Error("输入错误，没有指定的映射"),this.reflexSettingError=new Error("转轮设定错误，转轮映射应当为由数字0～25组成的长度为26且元素不重复的数组"),this.currentPosition=0,this.setWheelPosition(t),26!==e.length)throw this.reflexSettingError;{const t={};if(e.forEach((e=>{if(t[e]=e,e<0||e>25)throw this.reflexSettingError})),26!==Object.keys(t).length)throw this.reflexSettingError;this.setting=e}}get position(){return this.currentPosition}setWheelPosition(e=-1){return this.currentPosition=-1!==e?+e%26:(this.currentPosition+1)%26,this}toLeft(e){const t=e;let r=-1;if(this.setting.some(((e,s)=>(r=s,e===t)))&&-1!==r)return(r+this.position)%26;throw this.notFindError}toRight(e){const t=e-this.position,r=t<0?t+26:t,s=this.setting[r]??-1;if(-1!==s)return s;throw this.notFindError}}class t{constructor(e){if(this.settingError=new Error("反射器设置错误，反射器设置应为数字0～25的相互映射，映射条目数量应为13，且不可重复，每个元素仅能出现一次"),this.notFindError=new Error("映射失败，请检查配置"),13!==e.length)throw this.settingError;const t={};if(e.forEach((e=>{if(e.value1<0||e.value1>25||e.value2<0||e.value2>25)throw this.settingError;t[e.value1]=e.value2,t[e.value2]=e.value1})),26!==Object.keys(t).length)throw this.settingError;this.reflexMap=t}getValue(e){const t=this.reflexMap[e]??-1;if(-1!==t)return t;throw this.notFindError}}const r=()=>{const e=new Map;return{addEventListener:(t,r)=>{const s=Date.now(),i=e.get(t)??new Map;return i.set(s,r),e.set(t,i),s},removeEventListener:(t,r)=>{const s=e.get(t);s&&(s.delete(r),e.set(t,s))},emitEvent:(t,r)=>{const s=e.get(t);s&&s.forEach((e=>{e(r)}))}}};class s{constructor(e=[]){this.wordMap=new Map,this.error=new Error("字符映射设置错误,每个字符只能被映射一次"),this.setWordMaps(e)}setWordMaps(e=[]){this.wordMap=new Map;const t={},r=/^[A-Z]$/;e.forEach((e=>{const s=e.value1.toUpperCase(),i=e.value2.toUpperCase();if(!r.test(s)||!r.test(i))throw this.error;t[s]=t[s]??1,t[i]=t[i]??1,this.wordMap.set(s,i),this.wordMap.set(i,s)}));for(const e in t)if(t[e]>1)throw this.error}getValue(e){return this.wordMap.get(e)??e}}var i=["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],o=[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25],[13,1,22,6,0,18,2,5,7,3,8,4,9,25,10,12,14,17,16,19,21,20,23,15,11,24],[7,4,0,1,12,21,16,3,24,5,6,9,14,10,13,8,11,15,17,2,23,18,20,22,25,19]],n=[0,0,0],h=[{value1:1,value2:2},{value1:3,value2:4},{value1:5,value2:6},{value1:7,value2:8},{value1:9,value2:10},{value1:11,value2:12},{value1:13,value2:14},{value1:15,value2:16},{value1:17,value2:18},{value1:19,value2:20},{value1:21,value2:22},{value1:23,value2:24},{value1:25,value2:0}],l=[],a={inputMapper:i,wheels:o,wheelsPosition:n,reflector:h,wordMaps:l};const p=Object.freeze({__proto__:null,inputMapper:i,wheels:o,wheelsPosition:n,reflector:h,wordMaps:l,default:a});exports.Enigma=class{constructor(e){this.wordMapper=new s(p.wordMaps);const{addEventListener:t,removeEventListener:i,emitEvent:o}=r();this.addEventListener=t,this.removeEventListener=i,this.emitEvent=o;const{inputMapper:n,wheels:h,wheelsPosition:l,reflector:a,wordMaps:u}=e??p;this.setInputMapper(n??p.inputMapper),this.setWheelsSetting(h??p.wheels),this.setWheelsPosition(l??p.wheelsPosition),this.setReflectorSetting(a??p.reflector),this.setWordMapperSetting(u??p.wordMaps)}get wheels(){return this._wheels}get reflector(){return this._reflector}get wheelsSetting(){return this._wheelsSetting}get reflectorSetting(){return this._reflectorSetting}get inputMapper(){return this._inputMapper}setReflectorSetting(e){return this._reflectorSetting=e,this._reflector=new t(e),this.emitEvent("reflectorSettingChange",e),this}setWheelsSetting(t){return this._wheelsSetting=t,this._wheels=[],this.wheelsSetting.forEach((t=>{this._wheels.push(new e(t))})),this._wheels.reverse(),this.emitEvent("wheelSettingChange",t),this.emitEvent("wheelPositionChange",this.wheels.map((e=>e.position)).reverse()),this}setInputMapper(e){return this._inputMapper=e.map((e=>e.toUpperCase())),this.emitEvent("inputMapperChange",e),this}setWheelsPosition(e){return this.wheelsPosition=e,this.wheelsPosition.reverse(),this.wheels.forEach(((e,t)=>{e.setWheelPosition(this.wheelsPosition[t]??0)})),this.emitEvent("wheelPositionChange",this.wheels.map((e=>e.position)).reverse()),this}setWordMapperSetting(e){return this.wordMapper.setWordMaps(e),this.emitEvent("wordMapsChange",e),this}input(e){const t=e.split("").map((e=>e.toUpperCase())),r=/^[A-Z]$/,s=[];t.forEach((e=>{if(r.test(e)){const t=this.wordMapper.getValue(e),r=this.inputMapper.indexOf(t);if(-1===r)throw new Error("非法输入");const i=this.wheelProcess(r,"left"),o=this.reflector.getValue(i),n=this.wheelProcess(o,"right"),h=this.inputMapper[n],l=this.wordMapper.getValue(h);s.push(l)}else s.push(e)}));const i=s.join("");return this.emitEvent("input",i),i}wheelProcess(e,t){let r=e;switch(t){case"left":this.increaseWheel(),this.wheels.forEach((e=>{r=e.toLeft(r)}));break;case"right":[...this.wheels].reverse().forEach((e=>{r=e.toRight(r)}));break}return r}increaseWheel(){this.wheels.some((e=>(e.setWheelPosition(),0!==e.position))),this.emitEvent("wheelPositionChange",this.wheels.map((e=>e.position)).reverse())}},exports.Reflector=t,exports.SettingTemplate=p,exports.Wheel=e,exports.WordMapper=s,exports.createEventHandler=r;
